// Package reports provides a way to render a workflow.Plan to an HTML document with
// a program that will let you read it. This is meant for a Plan that is running on a local
// machine.
package reports

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"context"
	"fmt"
	"io/fs"
	"path/filepath"
	"runtime"
	"sync"

	"github.com/element-of-surprise/coercion/workflow"
	"github.com/element-of-surprise/coercion/workflow/utils/html/internal/embedded"
	"github.com/element-of-surprise/coercion/workflow/utils/walk"

	"github.com/spf13/afero"

	_ "embed"
)

// bufPool is a pool of *bytes.Buffer objects. You may use this to loweer
// the number of allocations when rendering Plans
type bufPool struct {
	pool sync.Pool
}

// Get returns a *bytes.Buffer from the pool. The buffer will be reset.
func (bp *bufPool) Get() *bytes.Buffer {
	return bp.pool.Get().(*bytes.Buffer)
}

// Put returns a *bytes.Buffer to the pool. The buffer is reset.
func (bp *bufPool) Put(b *bytes.Buffer) {
	b.Reset()

	bp.pool.Put(b)
}

type renderOptions struct {
}

// RenderOption is an optional argument for Render.
type RenderOption func(renderOptions) (renderOptions, error)

var bufferPool = &bufPool{
	pool: sync.Pool{
		New: func() any {
			return &bytes.Buffer{}
		},
	},
}

// Render renders a workflow.Plan to an HTML document. This may alter the Plan object to
// eliminate Request and Response fields that have fields marked with the `coerce:"secure"` tag.
func Render(ctx context.Context, plan *workflow.Plan, options ...RenderOption) (fs.ReadFileFS, error) {
	opts := renderOptions{}
	for _, opt := range options {
		var err error
		opts, err = opt(opts)
		if err != nil {
			return nil, err
		}
	}

	var b = bufferPool.Get()
	defer bufferPool.Put(b)

	// Remove any secrets from the plan.
	workflow.Secure(plan)

	fs := afero.NewMemMapFs()

	if err := embedded.Tmpls.ExecuteTemplate(b, "plan.tmpl", plan); err != nil {
		return nil, err
	}

	if err := afero.WriteFile(fs, "plan.html", b.Bytes(), 0644); err != nil {
		return nil, err
	}

	for item := range walk.Plan(ctx, plan) {
		var b = bufferPool.Get()
		defer bufferPool.Put(b)

		switch item.Value.Type() {
		case workflow.OTSequence:
			seq := item.Sequence()
			if err := embedded.Tmpls.ExecuteTemplate(b, "sequence.tmpl", seq); err != nil {
				return nil, err
			}
			fs.Mkdir("sequences", 0755)
			if err := afero.WriteFile(fs, fmt.Sprintf("sequences/%s.html", seq.ID), b.Bytes(), 0644); err != nil {
				return nil, err
			}
		case workflow.OTAction:
			act := item.Action()
			if err := embedded.Tmpls.ExecuteTemplate(b, "action.tmpl", act); err != nil {
				return nil, err
			}
			fs.Mkdir("actions", 0755)
			if err := afero.WriteFile(fs, fmt.Sprintf("actions/%s.html", act.ID), b.Bytes(), 0644); err != nil {
				return nil, err
			}
		}
		// Skip all other types.
	}

	return FS{fs}, nil
}

type downloadOptions struct {
	executable    bool
	renderOptions []RenderOption
}

func (d downloadOptions) defaults() downloadOptions {
	d.executable = true
	return d
}

// DownloadOption is an optional argument for Download.
type DownloadOption func(opt downloadOptions) (downloadOptions, error)

// WithExecutable determines if the reporter executable should be included in the tarball.
// The default is true.
func WithExecutable(b bool) DownloadOption {
	return func(opt downloadOptions) (downloadOptions, error) {
		opt.executable = b
		return opt, nil
	}
}

// WithRenderOptions sets the RenderOptions for the Render function.
func WithRenderOptions(opts ...RenderOption) DownloadOption {
	return func(opt downloadOptions) (downloadOptions, error) {
		opt.renderOptions = opts
		return opt, nil
	}
}

// Download downloads a tarball (.tar.gz) of the html files generated by Render and
// a binary to read it.
func Download(ctx context.Context, plan *workflow.Plan, options ...DownloadOption) (b []byte, err error) {
	opts := downloadOptions{}.defaults()
	for _, o := range options {
		var err error
		opts, err = o(opts)
		if err != nil {
			return nil, err
		}
	}

	var reportBinary []byte
	switch runtime.GOOS {
	case "darwin":
		switch runtime.GOARCH {
		case "amd64":
			reportBinary = embedded.ReporterDarwinAmd64
		case "arm64":
			reportBinary = embedded.ReporterDarwinArm64
		default:
			return nil, fmt.Errorf("unsupported architecture %s", runtime.GOARCH)
		}
	case "linux":
		switch runtime.GOARCH {
		case "amd64":
			reportBinary = embedded.ReporterLinuxAmd64
		case "arm64":
			reportBinary = embedded.ReporterLinuxArm64
		default:
			return nil, fmt.Errorf("unsupported architecture %s", runtime.GOARCH)
		}
	case "windows":
		switch runtime.GOARCH {
		case "amd64":
			reportBinary = embedded.ReporterWindowsAmd64
		default:
			return nil, fmt.Errorf("unsupported architecture %s", runtime.GOARCH)
		}
	default:
		return nil, fmt.Errorf("unsupported OS %s", runtime.GOOS)
	}

	f, err := Render(ctx, plan, opts.renderOptions...)
	if err != nil {
		return nil, err
	}

	buff := &bytes.Buffer{}
	defer func() {
		if err != nil {
			return
		}
		b = buff.Bytes()
	}()

	gzipWriter := gzip.NewWriter(buff)
	defer gzipWriter.Close()

	tarWriter := tar.NewWriter(gzipWriter)
	defer tarWriter.Close()

	reporterName := "reporter"
	if runtime.GOOS == "windows" {
		reporterName += ".exe"
	}

	const rootDir = "reports"
	const htmlDir = "html"

	// Write our root directory.
	err = tarWriter.WriteHeader(
		&tar.Header{
			Name:     filepath.Join(rootDir, "reports"),
			Mode:     0755,
			Typeflag: tar.TypeDir,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("problem writing root directory to tarball: %w", err)
	}

	// Write our reporter binary.
	if opts.executable {
		tarWriter.WriteHeader(
			&tar.Header{
				Name: filepath.Join(rootDir, reporterName),
				Size: int64(len(reportBinary)),
				Mode: 0770,
			},
		)
	}

	_, err = tarWriter.Write(reportBinary)
	if err != nil {
		return nil, err
	}

	walkErr := fs.WalkDir(
		f,
		".",
		func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}

			if d.IsDir() {
				err := tarWriter.WriteHeader(
					&tar.Header{
						Name:     filepath.Join(rootDir, htmlDir, path),
						Mode:     0755,
						Typeflag: tar.TypeDir,
					},
				)
				if err != nil {
					return fmt.Errorf("problem writing directory(%s) to tarball: %w", path, err)
				}
				return nil
			}

			data, err := afero.ReadFile(f.(FS).fs, path)
			if err != nil {
				return fmt.Errorf("problem reading file(%s) for tarball: %w", path, err)
			}
			err = tarWriter.WriteHeader(
				&tar.Header{
					Name: filepath.Join(rootDir, htmlDir, path),
					Size: int64(len(data)),
					Mode: 0660,
				},
			)
			if err != nil {
				return fmt.Errorf("problem writing file(%s) to tarball: %w", path, err)
			}
			_, err = tarWriter.Write(data)
			if err != nil {
				return fmt.Errorf("problem writing file(%s) to tarball: %w", path, err)
			}
			return nil
		},
	)
	if walkErr != nil {
		return nil, err
	}
	return nil, nil // b gets set in the defer.
}

// FS is a wrapper around afero.Fs to implement fs.FS interface.
type FS struct {
	fs afero.Fs
}

func (f FS) Open(name string) (fs.File, error) {
	return f.fs.Open(name)
}

func (f FS) ReadFile(name string) ([]byte, error) {
	return afero.ReadFile(f.fs, name)
}
